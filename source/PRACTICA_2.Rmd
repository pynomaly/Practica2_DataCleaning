---
title: "Práctica 2 - Tipología y Ciclo de Vida de los Datos"
author: "Esteban Braganza Cajas y Ana Álvarez Sánchez"
date: "2024-05-22"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, results = 'markup')
```

# 1. Descripción del dataset
¿Por qué es importante y qué pregunta/problema pretende responder? Resume brevemente las variables que lo forman y su tamaño.

PREGUNTA/PROBLEMA A RESPONDER:

Factores de los que depende el número de favoritos.




```{r}
data <- read.csv("../data/images_db.csv")
```

El fichero de datos contiene `r nrow(data)` registros y  `r ncol(data)` variables:

* `search_topic`: la imagen es resultado de la búsqueda por este tema
* `page_num`: la imagen aparece en este número de página de la búsqueda
* `image_page`: enlace a la página con la información de la imagen
* `image_url`: enlace a la imagen
* `image_title`: título de la imagen
* `image_author`: autor/a de la imagen
* `image_favs`: número de veces que le han dado a “me gusta” en la imagen
* `image_com`: número de comentarios que tiene la imagen
* `image_views`: número de vistas a la imagen
* `private_collections`: número de veces que ha sido incluida en una colección privada
* `tags`: etiquetas que se le han asignado a la imagen para facilitar su descubrimiento
* `location`: país o localización geográfica, si el autor la quiere identificar description: campo de texto abierto creado por el autor, que acompaña a la imagen. Puede incluir detalles técnicos o enlaces a las redes sociales del autor/a.
* `description`: descripción de la imagen que hace el autor. 
* `image_px`: dimensiones de la imagen, en pixeles
* `image_size`: peso de la imagen en MB.
* `published_date`: fecha de publicación de la imagen.
* `last_comment`: último comentario añadido a la imagen.
* `license`: licencia de la imagen

En cuanto a la descripción de cada una de estas variables:

* Las variables description, image_title y last_comment son campos de texto abiertos.

* Las variables image_url, image_page incluyen los enlaces a la página de la imagen y a la imagen en sí.

* La variable `search_topic` incluye `r length(unique(data$search_topic))` posibilidades, que son: `r toString(unique(data$search_topic))`. Las frecuencias de cada una de estas categorías en el conjunto de datos es esta:
```{r}
knitr::kable(table(data$search_topic))
```

* La variable `page_num` incluye `r length(unique(data$page_num))` posibilidades, que están en el rango `r range(data$page_num)`, porque en la descarga se han elegido las primeras 15 páginas de cada topic buscado.

```{r}
hist(data$page_num)
```


* Las variables `image_page`, `image_url`, `image_title`, `description` y `last_comment` son variables de tipo texto.

* La variable `image_author` incluye `r length(unique(data$image_author))` posibilidades. El autor/a con más registros tiene `r max(table(data$image_author))` obras. `r sum(table(data$image_author) == 1)` tienen una sola obra en el dataset. La media de imágenes por autor es de `r round(mean(table(data$image_author)), 2)`.

```{r}
frecuencias <- table(data$image_author)
df_frecuencias <- as.data.frame(frecuencias)
df_frecuencias_ordenado <- df_frecuencias[order(-df_frecuencias$Freq), ]

knitr::kable(head(df_frecuencias_ordenado, 10))

```

* La variable `image_favs` es numérica, con un valor mínimo de `r min(data$image_favs)`, un valor máximo de `r max(data$image_favs)`, una media de `r round(mean(data$image_favs), 2)`, con esta distribución:

```{r}
hist(data$image_favs)
```

* La variable `image_com` es numérica, con un valor mínimo de `r min(data$image_com)`, un valor máximo de `r max(data$image_com)`, una media de `r round(mean(data$image_com), 2)`, con esta distribución:

```{r}
hist(data$image_com)
```

* La variable `image_views` es numérica, con un valor mínimo de `r min(data$image_views)`, un valor máximo de `r max(data$image_views)`, una media de `r round(mean(data$image_views), 2)`, una mediana de `r median(data$image_views)`, con esta distribución:

```{r}
boxplot(data$image_views)
```
Esto indica la presencia de outliers en esta variable.

* La variable `private_collections` es numérica, con un valor mínimo de `r min(data$private_collections)`, un valor máximo de `r max(data$private_collections)`, una media de `r round(mean(data$private_collections), 2)`, con esta distribución:

```{r}
boxplot(data$private_collections)
```
En `r round(sum(data$private_collections == 0) / nrow(data) *100, 2)`% de los registros no están en ninguna colección privada. Puede ser una variable que no aporte demasiada información.

* La variable `tags` es de tipo character e incluye una lista de tags con los que el autor/a de la imagen la ha etiquetado.


* La variable `image_size` es numérica, con un valor mínimo de `r min(data$image_size)`, un valor máximo de `r max(data$image_size)`, una media de `r round(mean(data$image_size))`, con esta distribución:

```{r}
hist(data$image_size)
```

En el apartado de limpieza de los datos, se limpiarán las variables `location` (candidata a ser eliminada por número de NA), `published_date` (conversión a tipo Date), `image_license`, unificando las licencias copyright y convirtiéndola a categórica, `image_px` (unificamos formato en ancho x largo y extraemos superficie de la imagen, el resto de valores los convertimos a NA). Se desarrolla en el apartado de limpieza de los datos.


# 2. Integración y selección de los datos de interés a analizar
Puede ser el resultado de adicionar diferentes datasets o una subselección útil de los datos originales, en base al objetivo que se quiera conseguir. Si se decide trabajar con una selección de los datos, es muy importante que esta esté debidamente justificada. Además, se recomienda mostrar un resumen de los datos que permita ver a simple vista las diferentes variables y sus rangos de valores.

PROPUESTA: eliminación de las variables de texto libre, como `description`, `image_url`, `image_page`, `last_comment`. Eliminación de las variables con gran número de NA (`location`). Mantener una de las dos variables de dimensiones: `size` o `superficie`, eliminar la otra.

```{r}
summary(data)
```

# 3. Limpieza de los datos
3.1. ¿Los datos contienen ceros, elementos vacíos u otros valores numéricos que indiquen la pérdida de datos? Gestiona cada uno de estos casos utilizando el método de imputación que consideres más adecuado.
3.2. Identifica y gestiona adecuadamente el tipo de dato de cada atributo (p.ej. conversión de variables categóricas en factor).
3.3. Identifica y gestiona los valores extremos.
3.4. Justifica la necesidad de otros métodos de limpieza para este dataset en particular y, de ser necesario, aplícalos.

* Conversión a factor de la variable categórica `search_topic`:

```{r}
data$search_topic <- as.factor(data$search_topic)
```

* La variable `location` tiene un alto porcentaje de valores vacíos (""), que constituyen el `r round((nrow(data[data$location == "", ]) / nrow(data)) * 100, 2)`% de los registros. Convertimos esos valores en NA para su mejor identificación.

```{r}
data$location[data$location == ""] <- NA
```

* La variable `published_date` es de tipo character, la convertimos a tipo Date. 

```{r}
# Extraemos la parte de la fecha (sin la hora)
data$published_date <- substr(data$published_date, 1, 10)

# Convertir a formato de fecha
data$published_date <- as.Date(data$published_date)
```

* La variable `image_license`, contiene muchos valores vacíos (""). Empezamos convirtiendo esos en NA.

```{r}
data$image_license[data$image_license == ""] <- NA
```

Todas las que tengan el símbolo "©" las sustituimos por la palabra Copyright:
```{r}
# Identificar las filas que contienen "©"
filas_con_copyright <- grep("©", data$image_license)

# Sustituir toda la celda por "Copyright" para las filas identificadas
data$image_license[filas_con_copyright] <- "Copyright"
```

```{r}
knitr::kable(table(data$image_license))
```

La convertimos en categórica:
```{r}
data$image_license <- as.factor(data$image_license)

str(data$image_license)

```

* La variable `image_px` es de tipo character e indica el tamaño de la imagen en píxeles, en formato "ancho x alto". Para poder utilizarla en nuestro análisis como una variable numérica. Antes de convertir los dos valores en numéricos, comprobamos que todos los datos aparecen en ese formato "ancho x alto":

```{r}
# Obtener los índices de las filas que no contienen "x"
filas_sin_x <- grep("x", data$image_px, invert = TRUE)

# Ver las filas que no contienen "x"
nrow(data[filas_sin_x, "image_px", drop = FALSE])

```
Hay 67 registros que no incluyen la x en el dato indicado. Estos datos podrían representar el número total de píxeles en la imagen, en lugar de especificar el ancho y el alto por separado.

Opción: ignorar estos valores, convirtiéndolos en NA, porque no podemos saber si las imágenes son cuadradas (mismo ancho y alto)

```{r}
data$image_px[filas_sin_x] <- NA
```


```{r}
# Filas que no tienen valores NA en la columna image_px
sin_na <- complete.cases(data$image_px)

# Extraer la cadena en dos partes (ancho y alto) para las filas sin NA
dimensiones <- strsplit(data$image_px[sin_na], "x")

# Convertir las partes a valores numéricos
ancho <- as.numeric(sapply(dimensiones, "[[", 1))
alto <- as.numeric(sapply(dimensiones, "[[", 2))

# Crear nuevas columnas en el data frame para el ancho y el alto y la superficie total
# data$ancho[sin_na] <- ancho
# data$alto[sin_na] <- alto
data$superficie[sin_na] <- ancho * alto

```


* La variable `image_views` es numérica, con un valor mínimo de `r min(data$image_views)`, un valor máximo de `r max(data$image_views)`, una media de `r round(mean(data$image_views), 2)`, una mediana de `r median(data$image_views)`, con esta distribución:

```{r}

hist(data$image_views)
```
Esto indica la presencia de outliers en esta variable.


Convertimos todos los valores en el dataset que son texto vacío ("") en NA, por si han quedado en alguna otra variable, puesto que se trata de valores ausentes.

```{r}
# Convertir todos los valores vacíos ("") en el dataset a NA
data <- data.frame(lapply(data, function(x) {
  x[x == ""] <- NA
  return(x)
}), stringsAsFactors = FALSE)

```

Valores ausentes de cada variable:
```{r}
colSums(is.na(data))
```

* Tratamiento de la variable `tags`: la convertimos en lista y sacamos la frecuencia de cada tag.

```{r}

# Función para limpiar y convertir las cadenas de tags en listas de tags
clean_and_split_tags <- function(tags_string) {
  # Elimina corchetes y comillas
  tags_string <- gsub("\\[|\\]|'", "", tags_string)  
  if (tags_string == "") {
    # Devuelve un vector vacío si la cadena está vacía
    return(character(0))  
  }
  strsplit(tags_string, ", ")[[1]]  # Dividir la cadena en una lista de tags
}

# Aplicar la función a la columna de tags
data$tags_list <- lapply(data$tags, clean_and_split_tags)

# Crear lista total de tags
all_tags <- unlist(data$tags_list)

# Crear una tabla de frecuencias
tag_frequencies <- table(all_tags)
tag_frequencies <- sort(tag_frequencies, decreasing = TRUE)
print(head(tag_frequencies))

```

* Creamos variable `favs` en 4 categorías

```{r}
# Normalizar la variable data$image_favs al rango [0, 1]
data$image_favs_normalized <- (data$image_favs - min(data$image_favs)) / (max(data$image_favs) - min(data$image_favs))

# Definir los cortes usando cuantiles
quantile_bins <- quantile(data$image_favs, probs = seq(0, 1, by = 0.25))

# Etiquetas para las categorías
quantile_labels <- c("Very Low", "Low", "Medium", "High")

# Convertir la variable en categórica usando los cuantiles
data$image_favs_cat <- cut(data$image_favs, breaks = quantile_bins, labels = quantile_labels, include.lowest = TRUE)

# Verificar la distribución de las categorías
table(data$image_favs_cat)

```

```{r}
# Ver los rangos de cada categoría
max_values_quantiles <- aggregate(image_favs ~ image_favs_cat, data = data, max)
min_values_quantiles <- aggregate(image_favs ~ image_favs_cat, data = data, min)

```


# 4. Análisis de los datos
4.1. Aplica un modelo supervisado y uno no supervisado a los datos y comenta los resultados obtenidos.
4.2. Aplica una prueba por contraste de hipótesis. Ten en cuenta que algunas de estas pruebas requieren verificar previamente la normalidad y homocedasticidad de los datos.


```{r}
#  Partición de los datos

library(caret)
library(randomForest)

set.seed(123)

trainIndex <- createDataPartition(data$image_favs_cat, p = .8, list = FALSE, times = 1)
data_train <- data[trainIndex,]
data_test <- data[-trainIndex,]

# Eliminar las variables de texto y la numérica de image_favs
selected_vars = c('image_favs_cat', 'search_topic', 'page_num', 'image_com', 'image_views', 'image_size', 'published_date', 'image_license')

data_train <- data_train[ , (names(data_train) %in% selected_vars)]
data_test <- data_test[ , (names(data_test) %in% selected_vars)]

# Eliminar filas con valores perdidos en data_train y data_test
data_train <- data_train[complete.cases(data_train), ]
data_test <- data_test[complete.cases(data_test), ]

```

La variable objetivo del modelo supervisado es image_favs_cat, que contiene 4 categorías que agrupan al número de favs que tiene una imagen (very low, low, medium, high).  En este caso, tu problema es de clasificación y no de regresión, ya que image_favs_cat contiene categorías en lugar de valores numéricos continuos. Vamos a usar un modelo supervisado de clasificación, como Random Forest, para predecir estas categorías.


```{r}
# Modelo supervisado: modelo de Random Forest
set.seed(42)
rf_model <- randomForest(image_favs_cat ~ ., data = data_train, importance = TRUE)

# Predicciones
predictions <- predict(rf_model, data_test)

# Evaluar el modelo
conf_matrix <- confusionMatrix(predictions, data_test$image_favs_cat)

# Mostrar resultados
print(conf_matrix)

```


Matriz de Confusión:
- **Very Low**: Clasificado correctamente 313 veces.
- **Low**: Clasificado correctamente 263 veces.
- **Medium**: Clasificado correctamente 258 veces.
- **High**: Clasificado correctamente 283 veces.

Overall Statistics:
- **Accuracy**: 0.8088 (80.88%)
El modelo clasifica correctamente aproximadamente el 80.88% de las instancias.

- **95% CI**: (0.7871, 0.8293)
El intervalo de confianza del 95% para la precisión se encuentra entre 78.71% y 82.93%.

- **No Information Rate (NIR)**: 0.2571
La tasa de no información indica la precisión que se obtendría al clasificar siempre en la clase más frecuente.

- **P-Value [Acc > NIR]**: < 2.2e-16
Indica que la precisión del modelo es significativamente mayor que la del modelo sin información.

- **Kappa**: 0.745
El índice de Kappa indica un buen acuerdo entre las predicciones del modelo y las clases reales.


```{r}
# Importancia de las variables
importance(rf_model)
```

* El número de vistas de la imagen es la variable más importante, lo que indica que tiene una gran influencia en la clasificación del número de favoritos. Parece lógico que cuanto más vista es una imagen, más personas la podrán marcar como favorita.

-> Crear otro indicador mejor: image_favs / image_views

* También son importantes para predecir el número de favoritos el número de comentarios, la fecha de publicación de la imagen, el tema de búsqueda y el tamaño de la imagen.

- **Precisión del Modelo**: La precisión del modelo es buena (80.88%), con una alta sensibilidad y especificidad en la mayoría de las clases.
- **Importancia de las Variables**: Las variables `image_views`, `image_com`, `published_date`, `search_topic` y `image_size` son las más influyentes en la clasificación del número de favoritos de las imágenes.


# Modelo no supervisado: clustering

```{r}
# modelo no supervisado usando clustering

# Seleccionar las variables numéricas para el clustering
data_numeric <- data_clean[, sapply(data_clean, is.numeric)]

# Escalar las variables numéricas
data_scaled <- scale(data_numeric)

# Aplicar el algoritmo k-means
set.seed(123)  # Para reproducibilidad
k <- 4  # Número de clústeres
kmeans_res <- kmeans(data_scaled, centers = k)

# Obtener los clústeres asignados a cada observación
cluster_labels <- kmeans_res$cluster

# Visualizar los resultados del clustering
table(cluster_labels)

# Resumen de los centroides de los clústeres
kmeans_res$centers


```

* Cluster 1: Este clúster parece estar compuesto por observaciones con valores relativamente altos en variables como image_favs, image_com e image_views, lo que sugiere que estas observaciones podrían representar imágenes populares con un alto número de favoritos, comentarios y vistas. Sin embargo, estas imágenes parecen estar distribuidas en varias páginas de búsqueda (page_num), lo que podría indicar una amplia distribución en diferentes contextos o temas.

* Cluster 2: Este clúster muestra valores altos en image_size, lo que podría indicar que las imágenes en este clúster son de mayor tamaño en términos de peso de archivo. Sin embargo, tienen valores más bajos en image_favs, image_com e image_views, lo que sugiere que estas imágenes podrían ser menos populares en términos de interacción y vistas. La baja page_num también puede indicar que estas imágenes están más concentradas en páginas específicas de búsqueda.

* Cluster 3: Este clúster se caracteriza por tener un valor alto en la variable superficie, lo que podría sugerir que estas imágenes tienen dimensiones físicas más grandes en términos de tamaño de píxeles o área de imagen. Sin embargo, las otras variables numéricas parecen estar en valores más moderados.

* Cluster 4: Este clúster muestra valores bajos en la mayoría de las características, lo que podría indicar un grupo de observaciones que son atípicas en términos de sus características numéricas en comparación con los otros clústeres. Es posible que estas observaciones representen un grupo separado de imágenes con características distintivas.



**Contraste de Hipótesis**

$H_0$: No hay asociación entre el tema de búsqueda (`search_topic`) y la categoría del número de favoritos (`image_favs_cat`).
$H_1$: Existe una asociación entre el tema de búsqueda (`search_topic`) y la categoría del número de favoritos (`image_favs_cat`).


```{r}
# Contraste de hipótesis, Test de Chi-cuadrado


# Crear una tabla de contingencia
contingency_table <- table(data$search_topic, data$image_favs_cat)

# Realizar el test de Chi-cuadrado
chi_square_test <- chisq.test(contingency_table)

# Resumen del test de Chi-cuadrado
print(chi_square_test)


```

El resultado del test de Chi-cuadrado indica una asociación altamente significativa entre el tema de búsqueda (search_topic) y la categoría del número de favoritos (image_favs_cat). El valor del estadístico de Chi-cuadrado es muy alto (2812.8), lo que sugiere que las diferencias observadas entre las frecuencias esperadas y observadas en la tabla de contingencia son significativas. Además, el p-valor es extremadamente pequeño (< 2.2e-16), lo que indica que la probabilidad de obtener estos resultados bajo la hipótesis nula (que no hay asociación entre las variables) es prácticamente nula.

Esto sugiere que el tema de búsqueda influye en la popularidad de las imágenes, lo que puede tener implicaciones importantes para la optimización de la búsqueda y la promoción de contenidos en tu plataforma.

# 5. Representación de los resultados a partir de tablas y gráficas
Este apartado se puede responder a lo largo de la práctica, sin necesidad de concentrar todas
las representaciones en este apartado. 

Se debe representar tanto el contenido del dataset para observar las proporciones y distribuciones de las diferentes variables una vez aplicada la etapa de limpieza, como los resultados obtenidos tras la etapa de análisis.

# 6. Resolución del problema
A partir de los resultados obtenidos, ¿cuáles son las conclusiones? ¿Los resultados permiten responder al problema?
